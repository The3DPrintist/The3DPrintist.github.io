<!DOCTYPE html>
<html>

<head>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="tool.css">
</head>

<body>

  <div id="glowbg"></div>
  <div id="blurbg"></div>
  <div id="bg"></div>
  
  <div style="margin-left: 15%">
    <h1>Diora Tool</h1>
    <p>Usefull for creating blocks for Diora</p>
    <a href=".." class="btn btn-outline-light" role="button">back to home page</a>
  </div>

<hr class="hline">

<script>
  const circle = document.getElementById("glowbg");
  window.onpointermove = event => { 
    const { clientX, clientY } = event;
    
    circle.animate({
      left: `${clientX}px`,
      top: `${clientY}px`
    }, { duration: 250, fill: "forwards" });
  }
</script>

<div class ="flexbox">

    <div class="input-div" style="flex:3;">
        <p>Drag & drop frames here</p>
        <input type="file" class="file" multiple="multiple" accept="image/jpeg, image/png, image/jpg">
    </div>

    <div class="flexsection" style="flex: 1; justify-content: center; align-items: center; display: flex;">
        <canvas id="animcanvas" width="64" height="64"></canvas>
    </div>

</div>

<div class="section" style="text-align: left;" id="warning">
</div>

<div class="section" style="overflow: auto">
    <canvas id="tablecanvas" width="64" height="64"></canvas>
</div>

<div class="section">
    <button class="btn btn-outline-light" onclick="ditherall()">Dither</button>
    <button class="btn btn-outline-light" onclick="debugprint()">Debug</button>
</div>

<script>
    const inputDiv = document.querySelector(".input-div")
    const input = document.querySelector("input")
    const animdisplay = document.querySelector("#animdisplay")
    const warning = document.querySelector("#warning")

    const animcanvas = document.getElementById("animcanvas");
    const rotctx = animcanvas.getContext("2d");

    const tablecanvas = document.getElementById("tablecanvas");
    const tablectx = tablecanvas.getContext("2d");

    image = new Image();
    image.onload = () => {
        Promise.all([
            // Cut out two sprites from the sprite sheet
            createImageBitmap(image, 0, 0, 64, 64),
        ]).then((sprites) => {
            // Draw each sprite onto the canvas
            tablectx.drawImage(image, 0, 0);
            rotctx.drawImage(image, 0, 0);
        });
    };

    image.src = "block.png";

    let imagesArray = []
    let animid = 0
    let animlen = 0

    input.addEventListener("change", () => {
        const files = input.files
        for (let i = 0; i < files.length; i++) {
            imagesArray.push(files[i])
        }
        displayImages()
    })

    inputDiv.addEventListener("drop", () => {
        if(e == null){
            return
        }

        e.preventDefault()
        const files = e.dataTransfer.files
        for (let i = 0; i < files.length; i++) {
            if (!files[i].type.match("image")) continue;

            if (imagesArray.every(image => image.name !== files[i].name))
            imagesArray.push(files[i])
        }
        displayImages()
    })

    function displayImages() {

        clearwarn()

        let images = ""

        animlen = imagesArray.length

        images += `<p>Loaded ${animlen} images</p>`

        let img = document.createElement('img');
        let iw = 0
        let ih = 0

        img.src = URL.createObjectURL(imagesArray[0])

        img.onload = function(){
            iw = img.width
            ih = img.height

            tablectx.canvas.width = iw * animlen
            tablectx.canvas.height = ih

            rotctx.canvas.width = iw
            rotctx.canvas.height = ih

            if(iw == 64 && ih == 64){
                addstat ("üìê", iw + "x" + ih)
            }else{
                addwarn ("Image size (" + iw + "x" + ih + ") may not be correct.")
            }

            if(animlen%45 == 0 || animlen == 1){
                addstat ("#Ô∏è‚É£", animlen)
            }else{
                addwarn ("Image count (" + animlen + ") may not be correct.")
            }

        }

        for (let i = 0; i < animlen; i++) {
            createImageBitmap(imagesArray[i]).then(imageBitmap=>{
                tablectx.drawImage(imageBitmap,i*iw,0);
            })
        }
    }

    function deleteImage(index) {
        imagesArray.splice(index, imagesArray.length)
        displayImages()
    }

    function addstat(icon, msg){
        warning.innerHTML += "<p>" + icon + ` ${msg}</p>`
    }

    function addwarn(msg){
        warning.innerHTML += `<p>üõë ${msg}</p>`
    }

    function clearwarn(){
        warning.innerHTML = ""
    }

    async function dither(idx){
        let blobcanvas = document.createElement("canvas");
        let bctx = blobcanvas.getContext("2d");

        createImageBitmap(imagesArray[idx]).then(imgbm=>{
            //console.log("1: " + imageBitmap.width + "," + imageBitmap.height)
            bctx.canvas.width = 64;
            bctx.canvas.height = 64;

            bctx.clearRect(0, 0, bctx.canvas.width, bctx.canvas.height);
            bctx.drawImage(imgbm,0,0)

            let dither = [[16/17,  8/17, 14/17,  6/17], [ 4/17, 12/17,  2/17, 10/17], [13/17,  5/17, 15/17,  7/17], [ 1/17,  9/17,  3/17, 11/17]];

            let dw = dither[0].length;
            let dh = dither.length;

            let w = [0xb1, 0xae, 0xa8];
            let b = [0x32, 0x2f, 0x29];


            let cw = bctx.canvas.width;
            let ch = bctx.canvas.height;

            //console.log("2: " + bctx.canvas.width + "," + bctx.canvas.height)
            //console.log("3: " + cw + "," + ch)
            let power = 2;
            let data = bctx.getImageData(0,0,64,64);

            let i=0, val;

            for (let y = 0; y < cw; y++) {
                for (let x = 0; x < ch; x++, i += 4) {
                    val = value(data.data, i);
                    val = Math.pow(val, power);

                    if(val > dither[y%dh][x%dw]){
                        setpx(data.data, i, w)
                    }else{
                        setpx(data.data, i, b)
                    }
                }
            }

            bctx.putImageData(data, 0, 0);

            let dithered = dataURItoBlob(blobcanvas.toDataURL());

            imagesArray[idx] = new File([dithered], idx, { type: "image/png", });
            //imagesArray[idx] = dithered;

            rendercount += 1;

            data = null;
        })
    }

    function getRandomInt(max) {
        return Math.floor(Math.random() * max);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    var rendercount = 0
    function ditherall(){
        rendercount = 0
        for (let i = 0; i < imagesArray.length; i++) {
            dither(i);
        }

        waitanddisplay();
    }

    function waitanddisplay(){
        if(rendercount != imagesArray.length) {
            window.setTimeout(waitanddisplay, 100); /* this checks the flag every 100 milliseconds*/
            console.log("waiting");
        } else {
            displayImages();
        }
    }

    function debugprint(){
        displayImages();
    }

    function blobToFile(theBlob, fileName){
        //A Blob() is almost a File() - it's just missing the two properties below which we will add
        theBlob.lastModifiedDate = new Date();
        theBlob.name = fileName;
        theBlob.type = "image/png";
        return theBlob;
    }

    function dataURItoBlob(dataURI) {
        // convert base64/URLEncoded data component to raw binary data held in a string
        let byteString;
        if (dataURI.split(',')[0].indexOf('base64') >= 0)
            byteString = atob(dataURI.split(',')[1]);
        else
            byteString = unescape(dataURI.split(',')[1]);

        // separate out the mime component
        let mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

        // write the bytes of the string to a typed array
        let ia = new Uint8Array(byteString.length);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }

        return new Blob([ia], {type:mimeString});
    }

    //L* (D65/2¬∞)
    function value(data,i){
        let r,g,b;

        r = data[i];
        g = data[i+1];
        b = data[i+2];

        let Y, yr;

        r /= 255;
		g /= 255;
		b /= 255;

        r = ((r > 0.04045) ? Math.pow((r+0.055)/1.055,2.4) : r/12.92) * 100;
		g = ((g > 0.04045) ? Math.pow((g+0.055)/1.055,2.4) : g/12.92) * 100;
		b = ((b > 0.04045) ? Math.pow((b+0.055)/1.055,2.4) : b/12.92) * 100;

		Y = (0.2126*r + 0.7152*g + 0.0722*b) / 100;
		yr = (Y > 0.008856) ? Math.pow(Y, 1/3) : (7.787 * Y) + 16/116;

		let L = (116*yr)-16;

        return (L/100);
    }

    function setpx(data,i,color){
        data[i] = color[0];
        data[i+1] = color[1];
        data[i+2] = color[2];
    }
        
    let start, previousTimeStamp;

    function animupdate(timeStamp) {

        if (start === undefined) {
            start = timeStamp;
        }   

        const elapsed = timeStamp - start;

        if(animlen != 0 && elapsed > 10){

            createImageBitmap(imagesArray[animid]).then(imageBitmap=>{
                rotctx.clearRect(0, 0, rotctx.canvas.width, rotctx.canvas.height);
                rotctx.drawImage(imageBitmap,0,0)
            })

            animid += 1
            if(animid >= animlen){
                animid = 0
            }
            start = timeStamp;
        }
        
        previousTimeStamp = timeStamp;
        window.requestAnimationFrame(animupdate);
    }

    window.requestAnimationFrame(animupdate);

</script>

</body>
</html>
